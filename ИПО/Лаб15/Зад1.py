#Функция slow_func принимает три аргумента: x, y и sleep.
#Она приостанавливает выполнение программы на количество секунд, указанных в аргументе sleep, используя функцию time.sleep(sleep).
#Затем она возвращает сумму x и y.
#Функция slow_func декорирована функцией timeit, которая измеряет время выполнения функции slow_func.
#Декоратор timeit определяет новую функцию timed, которая замеряет время перед и после вызова slow_func,
#вычисляет разницу (в миллисекундах) и выводит имя функции, ее аргументы и время выполнения.
#Затем timed возвращает результат slow_func.
#В итоге, когда вы вызываете slow_func(10, 20, sleep=2), программа приостанавливается на 2 секунды,
#затем возвращает сумму 10 и 20 (то есть 30), и выводит время, затраченное на выполнение функции slow_func.
#Обратите внимание, что time.sleep(sleep) не делает вычисления функции slow_func медленнее в традиционном понимании
#(то есть она не добавляет дополнительных операций или увеличивает сложность алгоритма).
#Вместо этого она просто приостанавливает выполнение на заданное количество времени.
#Это может быть полезно для имитации функций, которые требуют некоторого времени для выполнения,
#например, из-за ожидания ввода пользователя или получения данных из Интернета.
import random
import time
from typing import List

def bubble_sort(lst: List[int]) -> List[int]:
    n = len(lst)
    for i in range(n):
        for j in range(0, n - i - 1):
            if lst[j] > lst[j + 1]:
                lst[j], lst[j + 1] = lst[j + 1], lst[j]
    return lst

sizes = [10, 100, 1000, 10000, 100000]
times = []

for size in sizes:
    lst = [random.randint(0, size) for _ in range(size)]
    start_time = time.time()
    bubble_sort(lst)
    end_time = time.time()
    times.append(end_time - start_time)

for size, time_taken in zip(sizes, times):
    print(f"Размер: {size}, Потраченное время: {time_taken} секунд")
    